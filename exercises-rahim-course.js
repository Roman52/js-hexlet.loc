
// 1 -------------------------------------------------------
/*
Реализуйте и экспортируйте по умолчанию функцию invertCase, которая меняет в строке регистр каждой буквы на противоположный.

invertCase('Hello, World!'); // hELLO, wORLD!
invertCase('I loVe JS');     // i LOvE js
 */

/*
const invertCase = (text) => {
  let res = '';
  const str = String(text);

  for (let i = 0; i < str.length; i += 1) {
    if (str[i] === str[i].toUpperCase()) {
      res += str[i].toLowerCase();
    } else {
      res += str[i].toUpperCase();
    }
  }

  return res;
};

console.log(invertCase('Hello, World!'));
 */

// 2 -------------------------------------------------------
/*
Реализуйте и экспортируйте по умолчанию функцию reverseInt, которая переворачивает цифры в переданном числе и возвращает новое число.

reverseInt(13); // 31
reverseInt(-123); // -321
reverseInt(8900); // 98
 */

/*
const reverseInt = (num) => {
  const str = String(num);
  let res = '';
  let minus = '';

  for (let i = 0; i < str.length; i += 1) {
    if (str[i] === '-') {
      minus = '-';
      continue;
    }

    res = str[i] + res;
  }

  return Number(minus + res);
};

console.log(reverseInt(-321));
 */

// 3 -------------------------------------------------------
/*
ДНК и РНК это последовательности нуклеотидов.
Четыре нуклеотида в ДНК это аденин (A), цитозин (C), гуанин (G) и тимин (T).
Четыре нуклеотида в РНК это аденин (A), цитозин (C), гуанин (G) и урацил (U).
Цепь РНК составляется на основе цепи ДНК последовательной заменой каждого нуклеотида:

G -> C
C -> G
T -> A
A -> U
dnaToRna.js
Реализуйте и экспортируйте функцию по умолчанию, которая принимает на вход цепь ДНК и возвращает соответствующую цепь РНК (совершает транскрипцию РНК).

Если во входном параметре нет ни одного нуклеотида (т.е. передана пустая строка), то функция должна вернуть пустую строку. Если в переданной цепи ДНК встретится "незнакомый" нуклеотид (не являющийся одним из четырех перечисленных выше), то функция должна вернуть null.

dnaToRna('ACGTGGTCTTAA'); // 'UGCACCAGAAUU'
dnaToRna('CCGTA'); // 'GGCAU'
dnaToRna(''); // ''
dnaToRna('ACNTG'); // null
 */

/*
const dnaToRna = (string) => {
  const str = String(string);
  let res = '';

  if (str === '') return '';

  for (let i = 0; i < str.length; i += 1) {
    if (str[i] !== 'A' && str[i] !== 'C' && str[i] !== 'G' && str[i] !== 'T') {
      return null;
    }

    switch (str[i]) {
      case 'A':
        res += 'U';
        break;
      case 'T':
        res += 'A';
        break;
      case 'C':
        res += 'G';
        break;
      case 'G':
        res += 'C';
        break;
    }
  }

  return res;
};

console.log(dnaToRna('CCGTA'));
 */

// 4 -------------------------------------------------------
/*
Напишите функцию diff, которая принимает два угла (integer), каждый от 0 до 360, и возвращает разницу между ними.
Угол между лучами измеряется двумя способами:

Функция должна вернуть наименьшее значение.

Примеры:
diff(0, 45) === 45;         // не 315, а 45, потому что 45 меньше
diff(0, 180) === 180;
diff(0, 190) === 170;       // не 190, а 170, потому что 170 меньше
diff(120, 280) === 160;

Можно встать и представить, что лицом обращены в сторону 0°. Повернуться на 90° вправо (это значение 1). Вернуться к 0° и повернуться в то же положение 90°, но вращаясь влево, наберётся 270° (это значение 2). Ответ – наименьшее из этих значений.

Mой алгоритм:
вычесть большее из меньшего (или просто вычесть одно из другого и взять модуль?), если разница <= 180 - то вернуть эту разницу
если разница > 180 то вернуть 360 - эту разницу

 */
/*
const diff = (angle1, angle2) => {
  const residual = Math.abs(angle1 - angle2);
  if (residual > 180) {
    return 360 - residual;
  }
  return residual;
};

console.log(diff(120, 280));
 */

// 5 -------------------------------------------------------
/*
Сумма квадратов первых десяти натуральных чисел это 1sup2 + 2sup2 + 3sup2 + ... + 10sup2 = 385.
Квадрат суммы первых десяти натуральных чисел это (1 + 2 + 3 + ... + 10)2 = 552 = 3025.
Разница между квадратом суммы и суммой квадратов первых десяти натуральных чисел: 3025 − 385 = 2640.

Напишите функцию sumSquareDifference, которая принимает аргумент n и возвращает разницу между квадратом суммы и суммой квадратов первых n натуральных чисел.

Нужно ли тут учитывать отрицательные числа? Натуральные числа это числа > 0. Я не учитывал отрицательные числа. При проверке нужно будет глянуть в тесты, учитывают ли их там или нет.


Можно сделать первые две функции через рекурсию. Первую у меня получилось сделать, вторую никак не пойму как можно сделать. Точнее как возвести в квалдат полученный результат. Проблема в том что в квадрат нужно возвести не каждое число (как в первой ф-и) а результат сложения, то есть возвести в кв. только один раз, а не на каждой итерации рекурсии. Должно быть решение для этого. Как поймать последнюю итерацию рекурсии - не знаю.
Посмотреть решение учителя когда буду сдавать - может там сделано на рекурсии.

А с помощью циклов сделал.

// рекурсия
const sumSquare = (n) => {
  if (n === 1) return n;
  return n ** 2 + sumSquare(n - 1);
}

const squareSum = (n) => {
  if (n === 1) return n;
  return n + squareSum(n - 1);
}
 */

// циклы
/*
const sumSquare = (n) => {
  const num = Number(n);
  let res = 0;

  for (let i = 1; i <= num; i += 1) {
    res += i ** 2;
  }

  return res;
}

const squareSum = (n) => {
  const num = Number(n);
  let res = 0;

  for (let i = 1; i <= num; i += 1) {
    res += i;
  }

  return res ** 2;
}

const sumSquareDifference = (n) => {
  return squareSum(n) - sumSquare(n);
}

// console.log(sumSquareDifference(10));
 */

// 6 -------------------------------------------------------
/*
Реализуйте и экспортируйте функцию по умолчанию, которая принимает на вход строку, состоящую только из открывающих и закрывающих круглых скобок, и проверяет является ли эта строка корректной. Пустая строка (отсутствие скобок) считается корректной.

Строка считается корректной (сбалансированной), если содержащаяся в ней скобочная структура соответствует требованиям:

Скобки — это парные структуры. У каждой открывающей скобки должна быть соответствующая ей закрывающая скобка.
Закрывающая скобка не должна идти впереди открывающей.

areBracketsBalanced('())('); // false
areBracketsBalanced('((())'); // false

areBracketsBalanced('(())');  // true
areBracketsBalanced('(())()'); // true
areBracketsBalanced('(()((((())))))'); // true

Закрывающая скобка не должна идти впереди открывающей означает, например, вот это ())(.
А структура скобок в приведенном Вами примере сбалансирована (т.е. третья скобка закрывает вторую).

Мой алгоритм:
1) Кол во откр ск должно быть равно кол ву закрыв
2) В цикле когда мы встречаем закрывающую скобку колличество открывающих скобок должно быть больше или равно чем закрывающих. (это и есть условие из задачи "Закрывающая скобка не должна идти впереди открывающей." своиме словами если описывать).
 */

/*
const areBracketsBalanced = (string) => {
  const str = String(string);
  if (str === '') return true;

  let openedBrakesCount = 0;
  let closedBrakesCount = 0;

  for (let i = 0; i < string.length; i += 1) {
    if (str[i] === '(') openedBrakesCount += 1;
    if (str[i] === ')') {
      closedBrakesCount += 1;

      if (closedBrakesCount > openedBrakesCount) {
        return false;
      }
    }
  }

  if (openedBrakesCount === closedBrakesCount) return true;
  return false;
}

console.log(areBracketsBalanced('(()((((())))))'));
 */

// 7 -------------------------------------------------------
/*
Функция Аккермана — простой пример вычислимой функции, которая не является примитивно рекурсивной.

Она обозначается A(m,n), принимает два неотрицательных целых числа в качестве параметров и возвращает натуральное число. Эта функция растёт очень быстро, например, число A(4,4) настолько велико, что количество цифр в порядке этого числа многократно превосходит количество атомов в наблюдаемой части Вселенной.

Функция Аккермана определяется рекурсивно для неотрицательных целых чисел m и n следующим образом:
photo

ackermann(0, 0); // 1
ackermann(2, 1); // 5
ackermann(2, 3); // 9

Мой алгоритм:
Я честно говоря не особо понял в чем прикол задания - по сути просто переписать математическую формулу в код.
 */

const ackermann = (m, n) => {
  if (m === 0) {
    return n + 1;
  }

  if (m > 0 && n === 0) {
    return ackermann(m - 1, 1);
  }

  if (m > 0 && n > 0) {
    return ackermann(m - 1, ackermann(m, n - 1));
  }
}

console.log(ackermann(0,0));

