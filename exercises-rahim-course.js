
// 1 -------------------------------------------------------
/*
Реализуйте и экспортируйте по умолчанию функцию invertCase, которая меняет в строке регистр каждой буквы на противоположный.

invertCase('Hello, World!'); // hELLO, wORLD!
invertCase('I loVe JS');     // i LOvE js
 */

/*
const invertCase = (text) => {
  let res = '';
  const str = String(text);

  for (let i = 0; i < str.length; i += 1) {
    if (str[i] === str[i].toUpperCase()) {
      res += str[i].toLowerCase();
    } else {
      res += str[i].toUpperCase();
    }
  }

  return res;
};

console.log(invertCase('Hello, World!'));
 */

// 2 -------------------------------------------------------
/*
Реализуйте и экспортируйте по умолчанию функцию reverseInt, которая переворачивает цифры в переданном числе и возвращает новое число.

reverseInt(13); // 31
reverseInt(-123); // -321
reverseInt(8900); // 98
 */

/*
const reverseInt = (num) => {
  const str = String(num);
  let res = '';
  let minus = '';

  for (let i = 0; i < str.length; i += 1) {
    if (str[i] === '-') {
      minus = '-';
      continue;
    }

    res = str[i] + res;
  }

  return Number(minus + res);
};

console.log(reverseInt(-321));
 */

// 3 -------------------------------------------------------
/*
ДНК и РНК это последовательности нуклеотидов.
Четыре нуклеотида в ДНК это аденин (A), цитозин (C), гуанин (G) и тимин (T).
Четыре нуклеотида в РНК это аденин (A), цитозин (C), гуанин (G) и урацил (U).
Цепь РНК составляется на основе цепи ДНК последовательной заменой каждого нуклеотида:

G -> C
C -> G
T -> A
A -> U
dnaToRna.js
Реализуйте и экспортируйте функцию по умолчанию, которая принимает на вход цепь ДНК и возвращает соответствующую цепь РНК (совершает транскрипцию РНК).

Если во входном параметре нет ни одного нуклеотида (т.е. передана пустая строка), то функция должна вернуть пустую строку. Если в переданной цепи ДНК встретится "незнакомый" нуклеотид (не являющийся одним из четырех перечисленных выше), то функция должна вернуть null.

dnaToRna('ACGTGGTCTTAA'); // 'UGCACCAGAAUU'
dnaToRna('CCGTA'); // 'GGCAU'
dnaToRna(''); // ''
dnaToRna('ACNTG'); // null
 */

/*
const dnaToRna = (string) => {
  const str = String(string);
  let res = '';

  if (str === '') return '';

  for (let i = 0; i < str.length; i += 1) {
    if (str[i] !== 'A' && str[i] !== 'C' && str[i] !== 'G' && str[i] !== 'T') {
      return null;
    }

    switch (str[i]) {
      case 'A':
        res += 'U';
        break;
      case 'T':
        res += 'A';
        break;
      case 'C':
        res += 'G';
        break;
      case 'G':
        res += 'C';
        break;
    }
  }

  return res;
};

console.log(dnaToRna('CCGTA'));
 */

// 4 -------------------------------------------------------
/*
Напишите функцию diff, которая принимает два угла (integer), каждый от 0 до 360, и возвращает разницу между ними.
Угол между лучами измеряется двумя способами:

Функция должна вернуть наименьшее значение.

Примеры:
diff(0, 45) === 45;         // не 315, а 45, потому что 45 меньше
diff(0, 180) === 180;
diff(0, 190) === 170;       // не 190, а 170, потому что 170 меньше
diff(120, 280) === 160;

Можно встать и представить, что лицом обращены в сторону 0°. Повернуться на 90° вправо (это значение 1). Вернуться к 0° и повернуться в то же положение 90°, но вращаясь влево, наберётся 270° (это значение 2). Ответ – наименьшее из этих значений.

Mой алгоритм:
вычесть большее из меньшего (или просто вычесть одно из другого и взять модуль?), если разница <= 180 - то вернуть эту разницу
если разница > 180 то вернуть 360 - эту разницу

 */
/*
const diff = (angle1, angle2) => {
  const residual = Math.abs(angle1 - angle2);
  if (residual > 180) {
    return 360 - residual;
  }
  return residual;
};

console.log(diff(120, 280));
 */

// 5 -------------------------------------------------------
/*
Сумма квадратов первых десяти натуральных чисел это 1sup2 + 2sup2 + 3sup2 + ... + 10sup2 = 385.
Квадрат суммы первых десяти натуральных чисел это (1 + 2 + 3 + ... + 10)2 = 552 = 3025.
Разница между квадратом суммы и суммой квадратов первых десяти натуральных чисел: 3025 − 385 = 2640.

Напишите функцию sumSquareDifference, которая принимает аргумент n и возвращает разницу между квадратом суммы и суммой квадратов первых n натуральных чисел.

Нужно ли тут учитывать отрицательные числа? Натуральные числа это числа > 0. Я не учитывал отрицательные числа. При проверке нужно будет глянуть в тесты, учитывают ли их там или нет.


Можно сделать первые две функции через рекурсию. Первую у меня получилось сделать, вторую никак не пойму как можно сделать. Точнее как возвести в квадрат полученный результат. Проблема в том что в квадрат нужно возвести не каждое число (как в первой ф-и) а результат сложения, то есть возвести в кв. только один раз, а не на каждой итерации рекурсии. Должно быть решение для этого. Как поймать последнюю итерацию рекурсии - не знаю.
Посмотреть решение учителя когда буду сдавать - может там сделано на рекурсии.

А с помощью циклов сделал.

// рекурсия
const sumSquare = (n) => {
  if (n === 1) return n;
  return n ** 2 + sumSquare(n - 1);
}

const squareSum = (n) => {
  if (n === 1) return n;
  return n + squareSum(n - 1);
}
 */

// циклы
/*
const sumSquare = (n) => {
  const num = Number(n);
  let res = 0;

  for (let i = 1; i <= num; i += 1) {
    res += i ** 2;
  }

  return res;
}

const squareSum = (n) => {
  const num = Number(n);
  let res = 0;

  for (let i = 1; i <= num; i += 1) {
    res += i;
  }

  return res ** 2;
}

const sumSquareDifference = (n) => {
  return squareSum(n) - sumSquare(n);
}

// console.log(sumSquareDifference(10));
 */

// 6 -------------------------------------------------------
/*
Реализуйте и экспортируйте функцию по умолчанию, которая принимает на вход строку, состоящую только из открывающих и закрывающих круглых скобок, и проверяет является ли эта строка корректной. Пустая строка (отсутствие скобок) считается корректной.

Строка считается корректной (сбалансированной), если содержащаяся в ней скобочная структура соответствует требованиям:

Скобки — это парные структуры. У каждой открывающей скобки должна быть соответствующая ей закрывающая скобка.
Закрывающая скобка не должна идти впереди открывающей.

areBracketsBalanced('())('); // false
areBracketsBalanced('((())'); // false

areBracketsBalanced('(())');  // true
areBracketsBalanced('(())()'); // true
areBracketsBalanced('(()((((())))))'); // true

Закрывающая скобка не должна идти впереди открывающей означает, например, вот это ())(.
А структура скобок в приведенном Вами примере сбалансирована (т.е. третья скобка закрывает вторую).

Мой алгоритм:
1) Кол во откр ск должно быть равно кол ву закрыв
2) В цикле когда мы встречаем закрывающую скобку колличество открывающих скобок должно быть больше или равно чем закрывающих. (это и есть условие из задачи "Закрывающая скобка не должна идти впереди открывающей." своиме словами если описывать).
 */

/*
const areBracketsBalanced = (string) => {
  const str = String(string);
  if (str === '') return true;

  let openedBrakesCount = 0;
  let closedBrakesCount = 0;

  for (let i = 0; i < string.length; i += 1) {
    if (str[i] === '(') openedBrakesCount += 1;
    if (str[i] === ')') {
      closedBrakesCount += 1;

      if (closedBrakesCount > openedBrakesCount) {
        return false;
      }
    }
  }

  if (openedBrakesCount === closedBrakesCount) return true;
  return false;
}

console.log(areBracketsBalanced('(()((((())))))'));
 */

// 7 -------------------------------------------------------
/*
Функция Аккермана — простой пример вычислимой функции, которая не является примитивно рекурсивной.

Она обозначается A(m,n), принимает два неотрицательных целых числа в качестве параметров и возвращает натуральное число. Эта функция растёт очень быстро, например, число A(4,4) настолько велико, что количество цифр в порядке этого числа многократно превосходит количество атомов в наблюдаемой части Вселенной.

Функция Аккермана определяется рекурсивно для неотрицательных целых чисел m и n следующим образом:
photo

ackermann(0, 0); // 1
ackermann(2, 1); // 5
ackermann(2, 3); // 9

Мой алгоритм:
Я честно говоря не особо понял в чем прикол задания - по сути просто переписать математическую формулу в код.
 */

/*
const ackermann = (m, n) => {
  if (m === 0) {
    return n + 1;
  }

  if (m > 0 && n === 0) {
    return ackermann(m - 1, 1);
  }

  if (m > 0 && n > 0) {
    return ackermann(m - 1, ackermann(m, n - 1));
  }
}

console.log(ackermann(0,0));
 */

// 8 -------------------------------------------------------
/*
Реализуйте и экспортируйте по умолчанию функцию, которая выводит (console.log) в терминал числа в диапазоне от begin до end. При этом:

Если число делится без остатка на 3, то вместо него выводится слово Fizz
Если число делится без остатка на 5, то вместо него выводится слово Buzz
Если число делится без остатка и на 3, и на 5, то вместо числа выводится слово FizzBuzz
В остальных случаях выводится само число
Функция принимает два параметра (begin и end), определяющих начало и конец диапазона (включительно). Для простоты считаем, что эти параметры являются целыми числами больше нуля. Если диапазон пуст (в случае, когда begin > end), то функция просто ничего не печатает.

Пример
Вызов функции:

fizzBuzz(11, 20);
Вывод в терминале:

11
Fizz
13
14
FizzBuzz
16
17
Fizz
19
Buzz
 */

/*
const fizzBuzz = (begin, end) => {
  if (begin > end) return;

  for (let i = begin; i <= end; i += 1) {
    if (i % 3 === 0 && i % 5 === 0) {
      console.log('FizzBuzz');
    } else if (i % 3 === 0) {
      console.log('Fizz');
    } else if (i % 5 === 0) {
      console.log('Buzz');
    } else {
      console.log(i);
    }
  }
};

fizzBuzz(11, 20);
 */

// 9 -------------------------------------------------------
/*
Реализуйте и экспортируйте по умолчанию функцию isPowerOfThree, которая определяет, является ли переданное число натуральной степенью тройки. Например, число 27 — это третья степень: 3^3, а 81 — это четвёртая: 3^4.

Пример:

isPowerOfThree(1); // true (3^0)
isPowerOfThree(2); // false
isPowerOfThree(9); // true (3^2)

Мой алгоритм:
Нужно делить число на 3 до тех пор пока не получим 3 или меньше 3.  Если получили 3 - после деления, то это степень тройки, если нет - то нет.

Сделал 2 мя способами - рекурсией и циклом.
 */

/*
const isPowerOfThree = (num) => {
  if (num === 1) return true;

  // by using recursion
  if (num % 3 === 0) {
    if (num === 3) {
      return true;
    }
    return isPowerOfThree(num / 3);
  }
  return false;


  // by using while
  while (num % 3 === 0) {
    if (num === 3) {
      return true;
    }

    num /= 3;

    if (num < 3) {
      return false;
    }
  }

  return false;
};

console.log(isPowerOfThree(3));
 */

// 10 -------------------------------------------------------
/*
"Счастливым" называют билет с номером, в котором сумма первой половины цифр равна сумме второй половины цифр. Номера могут быть произвольной длины, с единственным условием, что количество цифр всегда чётно, например: 33 или 2341 и так далее.

Билет с номером 385916 — счастливый, так как 3 + 8 + 5 = 9 + 1 + 6. Билет с номером 231002 не является счастливым, так как 2 + 3 + 1 != 0 + 0 + 2.

isHappyTicket.js
Реализуйте и экспортируйте по умолчанию функцию isHappyTicket, проверяющую является ли номер счастливым (номер — всегда строка). Функция должна возвращать true, если билет счастливый, или false, если нет.

Примеры использования:
isHappyTicket('385916'); // true
isHappyTicket('231002'); // false
isHappyTicket('1222');   // false
isHappyTicket('054702'); // true
isHappyTicket('00');     // true

Сделал легко.
 */

/*
const isHappyTicket = (str) => {
  if (str.length % 2 !== 0) {
    return false;
  }

  const lengthHalf = str.length / 2;
  let sumOfPart1 = 0;
  let sumOfPart2 = 0;

  for (let i = 0; i < str.length; i += 1) {
    if (i < lengthHalf) {
      sumOfPart1 += Number(str[i]);
    } else {
      sumOfPart2 += Number(str[i]);
    }
  }

  return sumOfPart1 === sumOfPart2;
};

console.log(isHappyTicket('1'));
 */

// 11 -------------------------------------------------------
/*
Реализуйте и экспортируйте функцию по умолчанию, которая переворачивает строку задом наперед, используя рекурсию.

Например:
reverse('str');    // rts
reverse('hexlet'); // telxeh
Попробуйте решить эту задачу, используя рекурсивный процесс. Для этого вам понадобится метод slice.

Не решил. Не знаю как сделать. Нужно еще думать, или см решение учителя.

Вот решение:
// Да, "прокрутил" весь процесс в голове несколько раз. Получается что саму строку мы получаем уже на последнем круге, при выполнении терминального условия. И после этого каждый символ возвращается подобно бусинам на нитку.

но я не понимаю где отвовить этот момент когда рекурсия крутит в обратную сторону.
Моя проблема в том, что я не знаю как дописывать в переменную при рекурсивном процессе. С циклом это легко. Нужно будет разобрать решение и понять как это работает.

 */

/*
const reverse = (str) => {
  console.log(str);

  if (str.length === 0) {
    console.log(111111111, str);
    const res = str;
    return res;
  }
  return reverse(str.slice(0, str.length - 1));

  // console.log(str.slice(1)); // вернет последний символ строки.
};

console.log(reverse('hello'));

// 6 символов длинна строки. Последний символ пятый.
// console.log(str.slice(-1)); // вернет последний символ строки.
// console.log(str.slice(1)); // вернет все до конца строки

// console.log(str.slice(-(str.length - 1))); // вернет строку без первой буквы

 */

// 12 -------------------------------------------------------
/*
Создайте функцию isPerfect, которая принимает число и возвращает true, если оно совершенное, и false — в ином случае.

Совершенное число — положительное целое число, равное сумме его положительных делителей (не считая само число). Например, 6 — идеальное число, потому что 6 = 1 + 2 + 3.

Сделал легко.
 */

/*
const isPerfect = (num) => {
  if (num === 0) return false;

  let res = 0;
  for (let i = num / 2; i > 0; i -= 1) {
    if (num % i === 0) {
      res += i;
    }
  }

  return res === num;
};

console.log(isPerfect(28));
 */

// 13 -------------------------------------------------------
/*
Программист, который работал на проекте до вас, разбросал все функции, связанные с математическими вычислениями по разным файлам с именами numbers1, numbers2 и numbers3. Причем имена функций тоже сделал странными: все функции в файле numbers2 заканчиваются на двойку, например, sum2.

Вы быстро поняли, что это неудобно и нужно создать единый интерфейс для доступа к ним (говорят "фасад"). Для этого необходимо импортировать все функции из всех перечисленных модулей в новый модуль в файле math.js.

math.js
Задача состоит в том, чтобы файл math.js импортировал в себя все функции из трех описанных выше файлов и выставил их наружу (то есть сделал их реэкспорт) под следующими именами: pow, sum, sub, sqrt и multi. А так же экспортировал функцию cube по умолчанию.

В этом задании специально не сказано, где какая функция и под каким именем лежит. А так же не сказано, как они все экспортируются. Цель этого задания в том, чтобы вы хорошо разобрались с системой модулей, что очень упростит вашу жизнь в дальнейшем. Огромная просьба не подсматривать решение и подумать самостоятельно, а в случае чего задать вопрос в комьюнити.

Не забудьте проанализировать файл с тестами, чтобы понять, как используется модуль math.js.
 */

// это надо делать на хекслете, смотреть файлы

// 14 -------------------------------------------------------
/*
Реализуйте и экспортируйте по умолчанию функцию, которая принимает на вход два аргумента - количество нулей и количество единиц, и определяет сколько есть способов размещения этих нулей и единиц так, что бы не было двух нулей идущих подряд.

Например, определим все способы размещения двух нулей и двух единиц. Существует шесть возможных способов размещения: 0011, 0101, 0110, 1001, 1010, 1100. В трех случаях содержится два нуля, идущих подряд: 0011, 1001 и 1100. Вычитаем их из общего числа и получаем три возможных способа: 0101, 0110 и 1010. Ответ - 3.

Примеры использования:

import withoutTwoZeros from './solution';

withoutTwoZeros(2, 2); // 3
withoutTwoZeros(1, 1); // 2
withoutTwoZeros(1, 3), // 4
withoutTwoZeros(2, 4); // 10

Не сделал. Тут долго нужно думать походу.
 */

// 15 -------------------------------------------------------
/*
Назовем счастливыми числами те, которые в результате ряда преобразований вида "сумма квадратов цифр" превратятся в единицу. Например:

7   => 7^2 = 49,
49  => 4^2 + 9^2 = 16 + 81 = 97,
97  => 9^2 + 7^2 = 81 + 49 = 130,
130 => 1^2 + 3^2 + 0^2 = 10,
10  => 1^2 + 0^2 = 1.
Вывод: исходное число 7 - счастливое.

isHappyNumber.js
Реализуйте и экспортируйте по умолчанию функцию, которая должна вернуть true, если число счастливое, и false, если нет. Количество итераций процесса поиска необходимо ограничить числом 10.

Подсказки
Воспользуйтесь вспомогательной функцией sumOfSquareDigits, которая принимает на вход число и возвращает "сумму квадратов цифр" этого числа.
Длина строки str находится так: str.length
 */

/*
const sumOfSquareDigits = (num) => {
  const str = String(num);
  let res = 0;

  for (let i = 0; i < str.length; i += 1) {
    res += Number(str[i]) ** 2;
  }

  return res;
}

const isHappyNumber = (num) => {
  let res = num;

  for (let i = 1; i <= 10; i += 1) {
    if (res === 1) {
      return true;
    } else {
      res = sumOfSquareDigits(res);
    }
  }

  return false;
}

console.log(isHappyNumber(7));
 */

// 16 -------------------------------------------------------
/*
Реализуйте и экспортируйте по умолчанию функцию, которая принимает на вход количество минут (прошедших с начала суток) и возвращает строку, являющуюся временем в формате чч:мм. Если количество минут содержит больше 24 часов (1 суток), то функция возвращает время прошеднее с полуночи последних суток.

Примеры
formattedTime(5); // 00:05
formattedTime(15); // 00:15
formattedTime(60); // 01:00
formattedTime(67); // 01:07
formattedTime(175); // 02:55
formattedTime(600); // 10:00
formattedTime(754); // 12:34
formattedTime(1504); // 01:04
Подсказки
Используйте функцию Math.floor(number) для округления до нижней границы.

Сделал сам. Не смотрел комменты.
 */

/*
const formattedTime = (time) => {
  const minutesInHour = 60;
  const hoursInDay = 24;
  let hoursCount = Math.floor(time / 60);
  let minutesCount = 0;

  if (hoursCount < hoursInDay) {
    minutesCount = time - hoursCount * minutesInHour;
  } else {
    minutesCount = time - hoursCount * minutesInHour;
    hoursCount %= hoursInDay;
  }

  if (hoursCount < 10) {
    hoursCount = `0${hoursCount}`;
  }

  if (minutesCount < 10) {
    minutesCount = `0${minutesCount}`;
  }

  return `${hoursCount}:${minutesCount}`;
};

console.log(formattedTime(7));
 */

console.log(
  process.env.NODE_ENV,
  process.env.PORT,
  process.env.HOST
);
